# Review Themes

Last updated: Project Materials — Backend (Links and Documents API)

1. **TreatWarningsAsErrors missing** — Always add `<TreatWarningsAsErrors>true</TreatWarningsAsErrors>` to every `<PropertyGroup>` in every .csproj file alongside `<Nullable>enable</Nullable>`; nullable warnings that don't fail the build silently accumulate into dead null-safety.
2. **Backslash path separators in .sln and .csproj** — Use forward slashes in all solution and project reference paths; backslashes are a Windows convention that breaks non-normalising tooling on Linux CI agents.
3. **Program not exposed for integration tests** — In top-level minimal-API projects, always append `public partial class Program { }` to `Program.cs` so `WebApplicationFactory<Program>` compiles in the test project.
4. **Speculative README references** — Only reference files and commands that exist in the current codebase; remove forward references to unimplemented infrastructure (e.g. `SeedData.cs`) until those files are scaffolded.
5. **Vite scaffold boilerplate not cleaned up** — After `npm create vite`, always delete unused template files (`App.css`, `assets/react.svg`, default `README.md`) and update `index.html` `<title>` to the real app name before committing.
6. **Duplicate ESLint config formats** — ESLint 9 uses flat config (`eslint.config.js`) exclusively and silently ignores `.eslintrc.cjs`; never commit both files; configure all plugins once in `eslint.config.js` using the flat config API.
7. **Development environment baked into Docker image** — Never set `ENV ASPNETCORE_ENVIRONMENT=Development` (or equivalent) in the Dockerfile itself; keep it only in docker-compose for local dev so production deployments default to a safe environment.
8. **Entity named for a concept it doesn't store** — When an entity is named after a temporal concept (e.g., `AuditionDate`, `EventDay`), verify it carries a `Date: DateOnly` or `DateTimeOffset` property; a time-only entity without a date is unschedulable and breaks downstream calendar/slot generation logic.
9. **Post-load tenant check instead of DB-level filter** — In repository `GetById` methods, always include the `OrganizationId` filter in the SQL query (via `EF.Property` or a typed predicate) rather than loading the entity first and checking in memory; a post-load check still materialises the wrong-tenant row into the EF change tracker.
10. **Hardcoded personal or real email addresses in seed data** — Use `@example.com` addresses (an IANA-reserved domain that cannot receive email) for all development seed data; never commit real personal addresses — they become a permanent privacy exposure in git history.
11. **Missing unique index on authentication key** — Whenever an entity uses an email address (or other unique token) as an authentication credential, declare a database-level unique index on that column; omitting it allows duplicate credentials and breaks lookup-by-identity logic silently.
12. **Validate all session paths, not just login** — When login checks a condition (e.g., `IsActive`, role, expiry), the validate/refresh path must check the same condition; a guard applied only at login leaves live sessions unaffected by subsequent state changes.
13. **In-memory session stores need TTL and eviction** — Any `ConcurrentDictionary`-backed session store must include an expiry timestamp and lazy eviction on lookup; without it, sessions are valid indefinitely and the collection grows without bound under repeated logins.
14. **Test every new auth component** — When adding authentication endpoints and services, always include unit tests for the service layer (success + each failure path) and integration tests for the HTTP endpoints; auth logic is high-value and high-risk to leave uncovered.
15. **Frontend auth store needs session rehydration** — An in-memory auth store (e.g. Zustand) loses state on page refresh; always add an app-mount validate call (`GET /auth/validate`) that rehydrates the store from the session cookie before ProtectedRoute checks run, otherwise every refresh logs the user out.
16. **Duplicate data-testid in responsive DOM** — When a component renders multiple visibility-toggled copies of the same element (e.g., desktop/tablet/mobile nav), all copies are present in the DOM simultaneously; add viewport suffixes to testids (`nav-desktop-*`, `nav-mobile-*`) or use a single canonical copy with `aria-hidden` on the rest, so test selectors stay unique.
17. **Mutations must use useMutation** — All API write operations (login, create, update, delete) must use Tanstack Query's `useMutation`, not raw `fetch`/`useEffect`; the project convention is explicit on this and raw fetch bypasses the consistent error/loading state management that useMutation provides.
18. **Seed data emails must stay in sync with test fixtures** — Any change to seed data email addresses must be applied simultaneously to every test file that sends those emails (unit tests, integration tests, e2e tests); stale email references in tests cause silent test-suite failures with no build error.
19. **Tests must be placed in the correct layer test project** — Each test class must live in the project that mirrors its subject layer (`Stretto.Application.Tests` for services, `Stretto.Infrastructure.Tests` for repositories/stores, `Stretto.Domain.Tests` for entities); placing tests in the wrong project creates false cross-layer dependencies and masks the architectural layer of a failure.
20. **Controllers must inject interfaces, not concrete services** — All Application-layer service dependencies in API controllers must be declared as interfaces and registered as `AddScoped<IFoo, FooService>()`; injecting concrete types prevents controller unit-testing and couples the API layer to implementation details.
21. **Always check response.ok before parsing fetch() responses** — In React pages and hooks, every `fetch()` call must check `response.ok` (or throw) before calling `.json()`; `fetch()` resolves on any HTTP status, so unchecked calls silently treat 401/400/500 error bodies as successful data, causing runtime crashes and silent data loss.
22. **Use the generated API client, not raw fetch** — When a TypeScript API client has been generated from the OpenAPI spec (`src/Stretto.Web/src/api/generated/`), all API calls in page components and hooks must use the generated service classes; bypassing the client with raw `fetch()` duplicates URL logic, ships dead code, and diverges from the established project convention.
23. **Page-level React components must be decomposed** — Single-page components that combine data fetching, mutation logic, and rendering regularly exceed the 40-line function-size guideline; always extract custom hooks for data concerns (e.g. `useVenues`, `useSaveVenue`) and sub-components for recurring UI patterns (e.g. form fields, table rows) to keep each function single-purpose and under ~40 lines.
24. **Test every new service and controller, not just auth** — Every new Application-layer service and API controller must ship with unit tests (service layer) and integration tests (controller HTTP contract) in the same commit; missing tests on the primary milestone deliverable is a blocker, not a follow-up.
25. **Service tests must use real repos, not hand-rolled fakes** — Use EF Core InMemory database with real `BaseRepository<T>` for service tests; hand-rolled fake repositories silently pass update assertions because their `UpdateAsync` is a no-op, making the tests unreliable; the project convention is explicit: no mocking unless unavoidable.
26. **Multi-step writes need safe ordering** — When a business operation activates one record and deactivates others (e.g. `MarkCurrentAsync`), always deactivate others first then activate the target; activating first creates a window where two records are simultaneously active, and any subsequent failure leaves the database in a corrupt state.
27. **Validation error keys must identify the actual failing field** — When a single validation check covers multiple fields (e.g. `startDate < lower || endDate > upper`), split it into per-field branches and use the key of the field that is actually invalid; collapsing all branches under one key (e.g. `"startDate"`) causes the client to highlight the wrong form field.
28. **Delete operations must clean up dependent entities** — When deleting an aggregate root (e.g. `Project`), always delete or cascade-delete all child/dependent records (`ProjectAssignment`, `Event`); without navigation properties, EF Core does not infer FK relationships and no cascade is set up, leaving orphaned rows in production databases.
29. **Shared controller helpers must be extracted to a base class** — When identical private methods (e.g. `GetSessionAsync`) are copied verbatim into three or more controllers, extract the method into a `ControllerBase`-derived base class or middleware; copy-paste helpers drift independently and create multiple places to fix a single authentication bug.
30. **Always pass ignoreCase:true to Enum.TryParse** — `Enum.TryParse<T>` is case-sensitive by default; a user submitting `"admin"` or `"ADMIN"` gets a 400 validation error even though it is a valid value; always call `Enum.TryParse<T>(value, ignoreCase: true, out var result)` when parsing user-supplied strings to enums.
31. **Validate target existence before any side effects in multi-step writes** — When a write operation may affect other records (e.g. clearing IsCurrent on sibling rows), always load and validate the target entity first; executing side effects before the existence check means a NotFoundException unwinds the application exception stack but leaves the already-persisted side effects in the database, corrupting state.
32. **Refactoring migrations must be completed atomically** — When extracting a shared method into a base class or shared module, migrate ALL call sites in the same commit; leaving some callers with the old private copy alongside the new base class creates two competing patterns, requires a second pass to finish the job, and negates the cleanup.
33. **Validate all optional FK fields, not just required ones** — When a service validates a required FK (e.g. ProjectId throws NotFoundException if missing), apply the same existence-and-org-scope check to every optional FK (e.g. VenueId); omitting it lets callers silently store orphaned references that manifest as unexpected nulls in response DTOs.
34. **Apply decomposition consistently across all pages in a milestone** — When a milestone refactors one page to extract a custom hook (e.g. `useVenueForm`), apply the same decomposition to every other page changed in that milestone that exceeds the function-size threshold; leaving some pages decomposed and others monolithic creates an inconsistent codebase and defers technical debt to a later milestone.
35. **Match frontend Zod validation format to backend serialization format** — When validating string fields that map to typed backend types (e.g. `TimeOnly`, `DateOnly`), verify how .NET serializes those types to JSON (e.g. `TimeOnly` → `"HH:mm:ss"`) and ensure the Zod regex or coercion accepts that format; a mismatch means edit forms cannot be saved without the user manually re-entering the pre-populated value.
36. **Always render mutation error states, not just loading states** — Every `useMutation` call that can fail (create, update, delete) must render a user-visible error message when `mutation.isError` is true; silently swallowing mutation errors is a class of bug that recurs across pages and leaves users with no feedback on data loss.
37. **Extract shared UI components rather than copy-pasting** — When a sub-component (e.g. `EventTypeBadge`) or local type definition is needed in two or more files in the same milestone, extract it to a shared component or types file immediately; copy-pasting creates divergence risk that compounds with every future change.
38. **Confirm before irreversible actions** — Every Delete button that triggers a non-undoable action must include a confirmation step (e.g. `window.confirm()` or an AlertDialog) before firing the mutation; a bare `onClick={() => deleteMutation.mutate()}` with no guard leads to accidental data loss in production.
39. **Keep milestone specs in sync with SPEC.md** — When an implementation changes to align with SPEC.md (e.g., status code 422→400), update the corresponding milestone spec validation criteria in the same commit; stale milestone specs become the authoritative reference for future builders and testers who write tests against them, causing hard-to-diagnose failures.
40. **Never mock @tanstack/react-query, Zustand, or react-hook-form in component tests** — Wrap test components in a real `QueryClientProvider` (new `QueryClient` per test) and stub only at the HTTP level (e.g., `msw`); mocking these libraries bypasses real validation, caching, and query-key behaviour, making tests pass for wrong implementations. The zustand mock is particularly dangerous because `let state = fn(...)` is closed over and not reset between tests, causing silent state pollution across test cases.
41. **Use enum types (not string) for domain-status fields** — Whenever an entity or DTO has a fixed set of valid status values (e.g., slot status: Pending/Accepted/Declined, attendance status: Present/Absent/Excused), model the field as a C# enum; using `string` with no validation allows any value to be persisted silently, and ASP.NET Core model binding will automatically reject unknown enum values with a 400 without any controller code.
42. **Validate FK parent existence in child record upserts** — When creating a new child record that references a parent via FK (e.g., `AttendanceRecord.EventId`), always validate the parent entity exists and belongs to the same org before persisting; skipping this allows callers to create orphaned records referencing non-existent or wrong-org entities, corrupting read-side aggregations silently.
43. **Match component auth guard to endpoint auth requirement** — When a component is conditionally rendered based on `user?.role`, every API endpoint it calls must permit that role; rendering `MemberAttendanceSection` only for Members while calling an Admin-only endpoint means the feature is silently broken for every user it targets; always verify each endpoint's auth requirement against the component's render condition before shipping.
44. **Always handle useQuery isError alongside isLoading** — Every `useQuery` call that renders data must also destructure `isError` and render a user-visible error message; omitting it causes an empty/blank UI with no feedback when the request fails, which is indistinguishable from "no data" and leaves users unable to diagnose or retry.
45. **Validate ALL required fields in public unauthenticated endpoints** — Public endpoints have no auth gate so all required fields must be validated explicitly before use; partial validation (e.g., checking `email` but not `firstName`/`lastName`) leaves server-side code exposed to null-dereference or garbage data from untrusted callers; validate every field that is required to produce a valid domain entity in the same validation pass.
46. **Check-then-act on shared mutable resources needs concurrency protection** — Whenever a service reads an entity, checks a condition (e.g., `slot.MemberId == null`), then updates it, two concurrent requests can both pass the check and both commit; use EF Core optimistic concurrency (`RowVersion`/`Timestamp`) or a DB-level unique constraint on the resource to guarantee at-most-one success; the pattern recurs across booking, assignment, and sign-up operations.
47. **Avoid redundant entity re-reads when delegating to a sub-method** — When a public service method validates an entity (e.g., `GetByIdAsync`) and then delegates to a private helper that repeats the same query, extract the load into a private method that accepts the already-loaded entity; loading the same row twice per request adds measurable latency and the double-read pattern silently multiplies as more callers are added.
48. **Cover every new exception type in GlobalExceptionHandlerMiddlewareTests** — Each new exception class added to `GlobalExceptionHandlerMiddleware` must have a corresponding unit test asserting the correct HTTP status code and JSON body shape; the middleware is the single global error-handling surface and an untested branch can silently regress to a 500 on a path that should return a structured error response.
