# Review Themes

Last updated: Venues — CRUD API

1. **TreatWarningsAsErrors missing** — Always add `<TreatWarningsAsErrors>true</TreatWarningsAsErrors>` to every `<PropertyGroup>` in every .csproj file alongside `<Nullable>enable</Nullable>`; nullable warnings that don't fail the build silently accumulate into dead null-safety.
2. **Backslash path separators in .sln and .csproj** — Use forward slashes in all solution and project reference paths; backslashes are a Windows convention that breaks non-normalising tooling on Linux CI agents.
3. **Program not exposed for integration tests** — In top-level minimal-API projects, always append `public partial class Program { }` to `Program.cs` so `WebApplicationFactory<Program>` compiles in the test project.
4. **Speculative README references** — Only reference files and commands that exist in the current codebase; remove forward references to unimplemented infrastructure (e.g. `SeedData.cs`) until those files are scaffolded.
5. **Vite scaffold boilerplate not cleaned up** — After `npm create vite`, always delete unused template files (`App.css`, `assets/react.svg`, default `README.md`) and update `index.html` `<title>` to the real app name before committing.
6. **Duplicate ESLint config formats** — ESLint 9 uses flat config (`eslint.config.js`) exclusively and silently ignores `.eslintrc.cjs`; never commit both files; configure all plugins once in `eslint.config.js` using the flat config API.
7. **Development environment baked into Docker image** — Never set `ENV ASPNETCORE_ENVIRONMENT=Development` (or equivalent) in the Dockerfile itself; keep it only in docker-compose for local dev so production deployments default to a safe environment.
8. **Entity named for a concept it doesn't store** — When an entity is named after a temporal concept (e.g., `AuditionDate`, `EventDay`), verify it carries a `Date: DateOnly` or `DateTimeOffset` property; a time-only entity without a date is unschedulable and breaks downstream calendar/slot generation logic.
9. **Post-load tenant check instead of DB-level filter** — In repository `GetById` methods, always include the `OrganizationId` filter in the SQL query (via `EF.Property` or a typed predicate) rather than loading the entity first and checking in memory; a post-load check still materialises the wrong-tenant row into the EF change tracker.
10. **Hardcoded personal or real email addresses in seed data** — Use `@example.com` addresses (an IANA-reserved domain that cannot receive email) for all development seed data; never commit real personal addresses — they become a permanent privacy exposure in git history.
11. **Missing unique index on authentication key** — Whenever an entity uses an email address (or other unique token) as an authentication credential, declare a database-level unique index on that column; omitting it allows duplicate credentials and breaks lookup-by-identity logic silently.
12. **Validate all session paths, not just login** — When login checks a condition (e.g., `IsActive`, role, expiry), the validate/refresh path must check the same condition; a guard applied only at login leaves live sessions unaffected by subsequent state changes.
13. **In-memory session stores need TTL and eviction** — Any `ConcurrentDictionary`-backed session store must include an expiry timestamp and lazy eviction on lookup; without it, sessions are valid indefinitely and the collection grows without bound under repeated logins.
14. **Test every new auth component** — When adding authentication endpoints and services, always include unit tests for the service layer (success + each failure path) and integration tests for the HTTP endpoints; auth logic is high-value and high-risk to leave uncovered.
15. **Frontend auth store needs session rehydration** — An in-memory auth store (e.g. Zustand) loses state on page refresh; always add an app-mount validate call (`GET /auth/validate`) that rehydrates the store from the session cookie before ProtectedRoute checks run, otherwise every refresh logs the user out.
16. **Duplicate data-testid in responsive DOM** — When a component renders multiple visibility-toggled copies of the same element (e.g., desktop/tablet/mobile nav), all copies are present in the DOM simultaneously; add viewport suffixes to testids (`nav-desktop-*`, `nav-mobile-*`) or use a single canonical copy with `aria-hidden` on the rest, so test selectors stay unique.
17. **Mutations must use useMutation** — All API write operations (login, create, update, delete) must use Tanstack Query's `useMutation`, not raw `fetch`/`useEffect`; the project convention is explicit on this and raw fetch bypasses the consistent error/loading state management that useMutation provides.
18. **Seed data emails must stay in sync with test fixtures** — Any change to seed data email addresses must be applied simultaneously to every test file that sends those emails (unit tests, integration tests, e2e tests); stale email references in tests cause silent test-suite failures with no build error.
19. **Tests must be placed in the correct layer test project** — Each test class must live in the project that mirrors its subject layer (`Stretto.Application.Tests` for services, `Stretto.Infrastructure.Tests` for repositories/stores, `Stretto.Domain.Tests` for entities); placing tests in the wrong project creates false cross-layer dependencies and masks the architectural layer of a failure.
20. **Controllers must inject interfaces, not concrete services** — All Application-layer service dependencies in API controllers must be declared as interfaces and registered as `AddScoped<IFoo, FooService>()`; injecting concrete types prevents controller unit-testing and couples the API layer to implementation details.
