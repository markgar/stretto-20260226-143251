# Review Themes

Last updated: Events — API

1. **TreatWarningsAsErrors missing** — Always add `<TreatWarningsAsErrors>true</TreatWarningsAsErrors>` to every `<PropertyGroup>` in every .csproj file alongside `<Nullable>enable</Nullable>`; nullable warnings that don't fail the build silently accumulate into dead null-safety.
2. **Backslash path separators in .sln and .csproj** — Use forward slashes in all solution and project reference paths; backslashes are a Windows convention that breaks non-normalising tooling on Linux CI agents.
3. **Program not exposed for integration tests** — In top-level minimal-API projects, always append `public partial class Program { }` to `Program.cs` so `WebApplicationFactory<Program>` compiles in the test project.
4. **Speculative README references** — Only reference files and commands that exist in the current codebase; remove forward references to unimplemented infrastructure (e.g. `SeedData.cs`) until those files are scaffolded.
5. **Vite scaffold boilerplate not cleaned up** — After `npm create vite`, always delete unused template files (`App.css`, `assets/react.svg`, default `README.md`) and update `index.html` `<title>` to the real app name before committing.
6. **Duplicate ESLint config formats** — ESLint 9 uses flat config (`eslint.config.js`) exclusively and silently ignores `.eslintrc.cjs`; never commit both files; configure all plugins once in `eslint.config.js` using the flat config API.
7. **Development environment baked into Docker image** — Never set `ENV ASPNETCORE_ENVIRONMENT=Development` (or equivalent) in the Dockerfile itself; keep it only in docker-compose for local dev so production deployments default to a safe environment.
8. **Entity named for a concept it doesn't store** — When an entity is named after a temporal concept (e.g., `AuditionDate`, `EventDay`), verify it carries a `Date: DateOnly` or `DateTimeOffset` property; a time-only entity without a date is unschedulable and breaks downstream calendar/slot generation logic.
9. **Post-load tenant check instead of DB-level filter** — In repository `GetById` methods, always include the `OrganizationId` filter in the SQL query (via `EF.Property` or a typed predicate) rather than loading the entity first and checking in memory; a post-load check still materialises the wrong-tenant row into the EF change tracker.
10. **Hardcoded personal or real email addresses in seed data** — Use `@example.com` addresses (an IANA-reserved domain that cannot receive email) for all development seed data; never commit real personal addresses — they become a permanent privacy exposure in git history.
11. **Missing unique index on authentication key** — Whenever an entity uses an email address (or other unique token) as an authentication credential, declare a database-level unique index on that column; omitting it allows duplicate credentials and breaks lookup-by-identity logic silently.
12. **Validate all session paths, not just login** — When login checks a condition (e.g., `IsActive`, role, expiry), the validate/refresh path must check the same condition; a guard applied only at login leaves live sessions unaffected by subsequent state changes.
13. **In-memory session stores need TTL and eviction** — Any `ConcurrentDictionary`-backed session store must include an expiry timestamp and lazy eviction on lookup; without it, sessions are valid indefinitely and the collection grows without bound under repeated logins.
14. **Test every new auth component** — When adding authentication endpoints and services, always include unit tests for the service layer (success + each failure path) and integration tests for the HTTP endpoints; auth logic is high-value and high-risk to leave uncovered.
15. **Frontend auth store needs session rehydration** — An in-memory auth store (e.g. Zustand) loses state on page refresh; always add an app-mount validate call (`GET /auth/validate`) that rehydrates the store from the session cookie before ProtectedRoute checks run, otherwise every refresh logs the user out.
16. **Duplicate data-testid in responsive DOM** — When a component renders multiple visibility-toggled copies of the same element (e.g., desktop/tablet/mobile nav), all copies are present in the DOM simultaneously; add viewport suffixes to testids (`nav-desktop-*`, `nav-mobile-*`) or use a single canonical copy with `aria-hidden` on the rest, so test selectors stay unique.
17. **Mutations must use useMutation** — All API write operations (login, create, update, delete) must use Tanstack Query's `useMutation`, not raw `fetch`/`useEffect`; the project convention is explicit on this and raw fetch bypasses the consistent error/loading state management that useMutation provides.
18. **Seed data emails must stay in sync with test fixtures** — Any change to seed data email addresses must be applied simultaneously to every test file that sends those emails (unit tests, integration tests, e2e tests); stale email references in tests cause silent test-suite failures with no build error.
19. **Tests must be placed in the correct layer test project** — Each test class must live in the project that mirrors its subject layer (`Stretto.Application.Tests` for services, `Stretto.Infrastructure.Tests` for repositories/stores, `Stretto.Domain.Tests` for entities); placing tests in the wrong project creates false cross-layer dependencies and masks the architectural layer of a failure.
20. **Controllers must inject interfaces, not concrete services** — All Application-layer service dependencies in API controllers must be declared as interfaces and registered as `AddScoped<IFoo, FooService>()`; injecting concrete types prevents controller unit-testing and couples the API layer to implementation details.
21. **Always check response.ok before parsing fetch() responses** — In React pages and hooks, every `fetch()` call must check `response.ok` (or throw) before calling `.json()`; `fetch()` resolves on any HTTP status, so unchecked calls silently treat 401/400/500 error bodies as successful data, causing runtime crashes and silent data loss.
22. **Use the generated API client, not raw fetch** — When a TypeScript API client has been generated from the OpenAPI spec (`src/Stretto.Web/src/api/generated/`), all API calls in page components and hooks must use the generated service classes; bypassing the client with raw `fetch()` duplicates URL logic, ships dead code, and diverges from the established project convention.
23. **Page-level React components must be decomposed** — Single-page components that combine data fetching, mutation logic, and rendering regularly exceed the 40-line function-size guideline; always extract custom hooks for data concerns (e.g. `useVenues`, `useSaveVenue`) and sub-components for recurring UI patterns (e.g. form fields, table rows) to keep each function single-purpose and under ~40 lines.
24. **Test every new service and controller, not just auth** — Every new Application-layer service and API controller must ship with unit tests (service layer) and integration tests (controller HTTP contract) in the same commit; missing tests on the primary milestone deliverable is a blocker, not a follow-up.
25. **Service tests must use real repos, not hand-rolled fakes** — Use EF Core InMemory database with real `BaseRepository<T>` for service tests; hand-rolled fake repositories silently pass update assertions because their `UpdateAsync` is a no-op, making the tests unreliable; the project convention is explicit: no mocking unless unavoidable.
26. **Multi-step writes need safe ordering** — When a business operation activates one record and deactivates others (e.g. `MarkCurrentAsync`), always deactivate others first then activate the target; activating first creates a window where two records are simultaneously active, and any subsequent failure leaves the database in a corrupt state.
27. **Validation error keys must identify the actual failing field** — When a single validation check covers multiple fields (e.g. `startDate < lower || endDate > upper`), split it into per-field branches and use the key of the field that is actually invalid; collapsing all branches under one key (e.g. `"startDate"`) causes the client to highlight the wrong form field.
28. **Delete operations must clean up dependent entities** — When deleting an aggregate root (e.g. `Project`), always delete or cascade-delete all child/dependent records (`ProjectAssignment`, `Event`); without navigation properties, EF Core does not infer FK relationships and no cascade is set up, leaving orphaned rows in production databases.
29. **Shared controller helpers must be extracted to a base class** — When identical private methods (e.g. `GetSessionAsync`) are copied verbatim into three or more controllers, extract the method into a `ControllerBase`-derived base class or middleware; copy-paste helpers drift independently and create multiple places to fix a single authentication bug.
30. **Always pass ignoreCase:true to Enum.TryParse** — `Enum.TryParse<T>` is case-sensitive by default; a user submitting `"admin"` or `"ADMIN"` gets a 400 validation error even though it is a valid value; always call `Enum.TryParse<T>(value, ignoreCase: true, out var result)` when parsing user-supplied strings to enums.
31. **Validate target existence before any side effects in multi-step writes** — When a write operation may affect other records (e.g. clearing IsCurrent on sibling rows), always load and validate the target entity first; executing side effects before the existence check means a NotFoundException unwinds the application exception stack but leaves the already-persisted side effects in the database, corrupting state.
32. **Refactoring migrations must be completed atomically** — When extracting a shared method into a base class or shared module, migrate ALL call sites in the same commit; leaving some callers with the old private copy alongside the new base class creates two competing patterns, requires a second pass to finish the job, and negates the cleanup.
33. **Validate all optional FK fields, not just required ones** — When a service validates a required FK (e.g. ProjectId throws NotFoundException if missing), apply the same existence-and-org-scope check to every optional FK (e.g. VenueId); omitting it lets callers silently store orphaned references that manifest as unexpected nulls in response DTOs.
34. **Apply decomposition consistently across all pages in a milestone** — When a milestone refactors one page to extract a custom hook (e.g. `useVenueForm`), apply the same decomposition to every other page changed in that milestone that exceeds the function-size threshold; leaving some pages decomposed and others monolithic creates an inconsistent codebase and defers technical debt to a later milestone.
